{"mappings":"0DACAA,OAAOC,eAAeC,EAAS,aAAc,CACzCC,OAAO,IAEXD,EAAQE,QACR,SAAyBC,EAAKC,EAAKH,GAC3BG,KAAOD,EACPL,OAAOC,eAAeI,EAAKC,EAAK,CAC5BH,MAAOA,EACPI,YAAY,EACZC,cAAc,EACdC,UAAU,IAGdJ,EAAIC,GAAOH,EAEf,OAAOE,C,ECmCX,MAAMK;;AAIYC,eAADC,GACbC,QAAQC,IAAI,SAAUF,E;;AAcCG,YAAbC,GACVC,KAAKC,MAAQF,C,CAGfG,YAAYC,GACVH,KAAKI,MAAQD,C;;AAaXC,YACF,OAAOJ,KAAKK,M,CAGVD,UAAMD,GACRH,KAAKK,OAASF,C,CAGZF,YACF,OAAOD,KAAKM,M,CAGVL,UAAMF,GACRC,KAAKM,OAASP,C;;AAzChBQ,aAAYC,MAAEA,EAAKJ,MAAEA,EAAKH,MAAEA,GAAU,IAIpCD,KAAKS,OAASD,EACdR,KAAKK,OAASD,EACdJ,KAAKM,OAASL,C;wBAbhBS;EAAAzB,EAAA,CAFIQ,EAEG,cAAc,mBAsDJ,IAAIA,EAAI,CACzBe,MAAO,OACPJ,MAAO,KACPH,MAAO,OAsDT,MAAMU,EAAO,IAVmB,cAlBI,MAKlCC,OAAOC,GACLjB,QAAQC,IAAI,GAAGG,KAAKc,iBAAKD,WACZb,KAARe,IAAMF,C,CANbN,YAAYO,EAAO,OAAQC,EAAK,GAC9Bf,KAAKc,KAAOA,EACZd,KAAKe,GAAKA,C,GAgBZR,YAAYO,EAAMC,EAAIC,GAIlBC,MAAMH,EAAMC,GACdf,KAAKgB,OAASA,C,GAIO,OAAQ,IAAM,OACvCpB,QAAQC,IAAIc,GACZA,EAAKC,OAAO","sources":["node_modules/@swc/helpers/lib/_define_property.js","src/js/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _defineProperty;\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n","/* Клаcсы\n * - обьявление\n * - конструктор\n * - методы\n * - static\n * - приватные свойства\n * - синтаксис публиных свойств и методы классов\n * - геттеры и сеттеры\n */\n\n// class Car {\n//   //! Статические свойства\n//   static description = 'About car class';\n//   //! Статический метод\n//   static carInfo(carObj) {\n//     console.log('carObg', carObj);\n//   }\n\n//   //* приватные свойства\n//   #test = 'test';\n\n//   //* публичные свойства\n//   mySuperCar = 555; // Тоже что и this.mySuperCar = 555 в итоге под капотом оно в это и приобразуется\n//   //! Все публичные свойства идут на екземпляр Пример с методом:\n//     changePrice = (newPrice) => {\n//         this.price = newPrice;\n//     };//! эта функция пошла на экземпляр, а это метод класа\n// //!     changePrice(newPrice) {\n// //!     this.price = newPrice;\n// //!   }, он идет на прототип\n\n//   //!обязательно\n//   constructor({ brand, model, price } = {}) {\n//     // console.log('Вызывается constructor');\n//     // console.log(this);\n\n//     this.brand = brand;\n//     this.model = model;\n//     this.price = price;\n//   }\n//   //! то что идет на protptype это метод класса\n\n//   changePrice(newPrice) {\n//     this.price = newPrice;\n//   }\n\n//   updateModel(newModel) {\n//     this.model = newModel;\n//   }\n// }\n\nclass Car {\n  //! Статические свойства\n  static description = 'About car class';\n  //! Статический метод\n  static carInfo(carObj) {\n    console.log('carObg', carObj);\n  }\n\n  //!обязательно\n  constructor({ brand, model, price } = {}) {\n    // console.log('Вызывается constructor');\n    // console.log(this);\n\n    this._brand = brand;\n    this._model = model;\n    this._price = price;\n  }\n  //! то что идет на protptype это метод класса\n\n  changePrice(newPrice) {\n    this.price = newPrice;\n  }\n\n  updateModel(newModel) {\n    this.model = newModel;\n  }\n\n  //! ГЕТТЕРЫ И СЕТТЕРЫ\n  // getModel() {\n  //     return this.model;// даже если тут изменится свойство все еще будет работать\n  // } //Метод получения свойства\n\n  // setModel(newModel) {\n  //     this.model = newModel;\n  // }// Метод обновления свойтва\n\n  //*геттер\n  get model() {\n    return this._model;\n  } //геттер не может называться именем свойства\n\n  set model(newModel) {\n    this._model = newModel;\n  }\n\n  get price() {\n    return this._price;\n  }\n\n  set price(newPrice) {\n    this._price = newPrice;\n  }\n}\n\n// console.dir(Car);\n\nconst carInstans = new Car({\n  brand: 'Audi',\n  model: 'Q3',\n  price: 35000,\n});\n\n// console.log(carInstans);\n// console.log(carInstans.price);\n// carInstans.price = 50000;\n// console.log(carInstans.price);\n// //? Обращение к геттеру\n// console.log(carInstans.model);\n// //? Обращение ы сеттеру\n// carInstans.model = 'Q4';\n// console.log(carInstans.model);\n\n// console.log(carInstans.getModel());\n\n// carInstans.setModel('Q4');\n\n// console.log(carInstans.getModel());\n\n/* НАСЛЕДОВАНИЕ\n * - extends\n * - super()\n */\n\n//* Делаем общий ласс родител для наших героев\n\nclass Hero {\n  constructor(name = 'hero', xp = 0) {\n    this.name = name;\n    this.xp = xp;\n  }\n  gainXp(amount) {\n    console.log(`${this.name} получает ${amount} опыта`);\n    this.xp += amount;\n  }\n}\n// console.dir(Hero);\n\n//? Делаем какого то героя\n// const Poly = new Hero({ name: 'Poly', xp: 1000 });\n// console.log(Poly);\n// Poly.gainXp(1000);\n\n//* Я хочу что бы воин наследовал свойства Hero\nclass Warrior extends Hero {\n  constructor(name, xp, weapon) {\n    // для того что бы все работало нужно \n    // в конструкторе ребенка вызвать конструктор \n    // родиеля через super()\n      super(name, xp);\n    this.weapon = weapon;\n  }\n}\n\nconst Poly = new Warrior('Poly', 1000, 'gun');\nconsole.log(Poly);\nPoly.gainXp(1000);\n"],"names":["Object","defineProperty","$da4b248c00322402$exports","value","default","obj","key","enumerable","configurable","writable","$85a5f86b715fe7db$var$Car","static","carObj","console","log","changePrice","newPrice","this","price","updateModel","newModel","model","_model","_price","constructor","brand","_brand","$parcel$interopDefault","$85a5f86b715fe7db$var$Poly","gainXp","amount","name","xp","weapon","super"],"version":3,"file":"index.43d8c9c3.js.map"}