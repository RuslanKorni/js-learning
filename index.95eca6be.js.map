{"mappings":"0DACAA,OAAOC,eAAeC,EAAS,aAAc,CACzCC,OAAO,IAEXD,EAAQE,QACR,SAAyBC,EAAKC,EAAKH,GAC3BG,KAAOD,EACPL,OAAOC,eAAeI,EAAKC,EAAK,CAC5BH,MAAOA,EACPI,YAAY,EACZC,cAAc,EACdC,UAAU,IAGdJ,EAAIC,GAAOH,EAEf,OAAOE,C,ECmCX,MAAMK;;AAIYC,eAADC,GACbC,QAAQC,IAAI,SAAUF,E;;AAcCG,YAAbC,GACVC,KAAKC,MAAQF,C,CAGfG,YAAYC,GACVH,KAAKI,MAAQD,C;;AAaXC,YACF,OAAOJ,KAAKK,M,CAGVD,UAAMD,GACRH,KAAKK,OAASF,C,CAGZF,YACF,OAAOD,KAAKM,M,CAGVL,UAAMF,GACRC,KAAKM,OAASP,C;;AAzChBQ,aAAYC,MAAEA,EAAKJ,MAAEA,EAAKH,MAAEA,GAAU,IAIpCD,KAAKS,OAASD,EACdR,KAAKK,OAASD,EACdJ,KAAKM,OAASL,C;wBAbhBS;EAAAzB,EAAA,CAFIQ,EAEG,cAAc,mBAsDJ,IAAIA,EAAI,CACzBe,MAAO,OACPJ,MAAO,KACPH,MAAO;;AA6DQ,MAAXU,EAAU,IAAIC,SAAQ,CAACC,EAASC,KACpC,MAAMC,EAAcC,KAAKC,SAAW,GAEpCC,YAAW,KACLH,GACFF,EAAQ,+BAGFC,EAAD,4BAAoC,GAC1C,IAAK,IAGVlB,QAAQC,IAAIc","sources":["node_modules/@swc/helpers/lib/_define_property.js","src/js/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _defineProperty;\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n","/* Клаcсы\n * - обьявление\n * - конструктор\n * - методы\n * - static\n * - приватные свойства\n * - синтаксис публиных свойств и методы классов\n * - геттеры и сеттеры\n */\n\n// class Car {\n//   //! Статические свойства\n//   static description = 'About car class';\n//   //! Статический метод\n//   static carInfo(carObj) {\n//     console.log('carObg', carObj);\n//   }\n\n//   //* приватные свойства\n//   #test = 'test';\n\n//   //* публичные свойства\n//   mySuperCar = 555; // Тоже что и this.mySuperCar = 555 в итоге под капотом оно в это и приобразуется\n//   //! Все публичные свойства идут на екземпляр Пример с методом:\n//     changePrice = (newPrice) => {\n//         this.price = newPrice;\n//     };//! эта функция пошла на экземпляр, а это метод класа\n// //!     changePrice(newPrice) {\n// //!     this.price = newPrice;\n// //!   }, он идет на прототип\n\n//   //!обязательно\n//   constructor({ brand, model, price } = {}) {\n//     // console.log('Вызывается constructor');\n//     // console.log(this);\n\n//     this.brand = brand;\n//     this.model = model;\n//     this.price = price;\n//   }\n//   //! то что идет на protptype это метод класса\n\n//   changePrice(newPrice) {\n//     this.price = newPrice;\n//   }\n\n//   updateModel(newModel) {\n//     this.model = newModel;\n//   }\n// }\n\nclass Car {\n  //! Статические свойства\n  static description = 'About car class';\n  //! Статический метод\n  static carInfo(carObj) {\n    console.log('carObg', carObj);\n  }\n\n  //!обязательно\n  constructor({ brand, model, price } = {}) {\n    // console.log('Вызывается constructor');\n    // console.log(this);\n\n    this._brand = brand;\n    this._model = model;\n    this._price = price;\n  }\n  //! то что идет на protptype это метод класса\n\n  changePrice(newPrice) {\n    this.price = newPrice;\n  }\n\n  updateModel(newModel) {\n    this.model = newModel;\n  }\n\n  //! ГЕТТЕРЫ И СЕТТЕРЫ\n  // getModel() {\n  //     return this.model;// даже если тут изменится свойство все еще будет работать\n  // } //Метод получения свойства\n\n  // setModel(newModel) {\n  //     this.model = newModel;\n  // }// Метод обновления свойтва\n\n  //*геттер\n  get model() {\n    return this._model;\n  } //геттер не может называться именем свойства\n\n  set model(newModel) {\n    this._model = newModel;\n  }\n\n  get price() {\n    return this._price;\n  }\n\n  set price(newPrice) {\n    this._price = newPrice;\n  }\n}\n\n// console.dir(Car);\n\nconst carInstans = new Car({\n  brand: 'Audi',\n  model: 'Q3',\n  price: 35000,\n});\n\n// console.log(carInstans);\n// console.log(carInstans.price);\n// carInstans.price = 50000;\n// console.log(carInstans.price);\n// //? Обращение к геттеру\n// console.log(carInstans.model);\n// //? Обращение ы сеттеру\n// carInstans.model = 'Q4';\n// console.log(carInstans.model);\n\n// console.log(carInstans.getModel());\n\n// carInstans.setModel('Q4');\n\n// console.log(carInstans.getModel());\n\n/* НАСЛЕДОВАНИЕ\n * - extends\n * - super()\n */\n\n//* Делаем общий ласс родител для наших героев\n\nclass Hero {\n  constructor(name = 'hero', xp = 0) {\n    this.name = name;\n    this.xp = xp;\n  }\n  gainXp(amount) {\n    console.log(`${this.name} получает ${amount} опыта`);\n    this.xp += amount;\n  }\n}\n// console.dir(Hero);\n\n//? Делаем какого то героя\n// const Poly = new Hero({ name: 'Poly', xp: 1000 });\n// console.log(Poly);\n// Poly.gainXp(1000);\n\n//* Я хочу что бы воин наследовал свойства Hero\nclass Warrior extends Hero {\n  constructor(name, xp, weapon) {\n    // для того что бы все работало нужно\n    // в конструкторе ребенка вызвать конструктор\n    // родиеля через super()\n    super(name, xp);\n    this.weapon = weapon;\n  }\n}\n\n// const Poly = new Warrior('Poly', 1000, 'gun');\n// console.log(Poly);\n// Poly.gainXp(1000);\n//*===================================================================================================\n//! Промисы\n\n//? Здесь содаем промис\nconst promise = new Promise((resolve, reject) => {\n  const canFullfill = Math.random() > 0.5;\n\n  setTimeout(() => {\n    if (canFullfill) {\n      resolve('All ok (исполнен fulfilled)');\n    }\n\n    reject('error (отклонен rejected)');\n  }, 2000);\n});\n\nconsole.log(promise);\n\n/*\n? then() это подписка на промис. then() буквально говорить если промис выполнился успешно то сделай это.\n? здесь делаем планровку\n*/\n// promise.then(result => {\n//   console.log('result:', result);\n// },\n//   error => {\n//     console.log('error:', error);\n//   }\n// );\n//! Концепция then(onSuccess, onError)\n//! В then() мы обрабатываем успешное выполнение.  В catch() Обрабатываем ошибку. finally() для снятия промиса, выполняется в любом случае.\n\n//* then() через функции\n// promise.then(onFulfilled, onError); //результат промисов можно получит ТОЛЬКО ВНУТРИ ЭТИХ КОЛЛБЕКОВ\n\n// function onFulfilled(result) {\n//   console.log(`✅ ${result}`);\n// };\n\n// function onError(error) {\n//   console.log(`❌ ${error}`);\n// };\n\n//* Цепочки промисов (chaining)\n//! Промис в цепоче возвращает промис\n// promise\n//   .then(result => {\n//     console.log(result);\n//     //эта коллбек функция передаст 5 в следующий then()\n//     return 5;\n//   })\n//   .then(\n//     //В Этоу колбук функцию придет 5 с предидущего then(). так как этот колбук ничег не возвращает в следующий колбек придет\n//     // undefient\n//     x => {\n//       console.log(x);\n//     }\n//   )\n//   .then(\n//     // этот then() вернет undefient\n//     y => {\n//       console.log(y);\n//     }\n//   );\n\n//* пример с catch()\n\n// promise\n//   .then(result => {\n//     console.log(result);\n//     //эта коллбек функция передаст 5 в следующий then()\n//     return 5;\n//   })\n//   .then(\n//     //В Этоу колбук функцию придет 5 с предидущего then(). так как этот колбук ничег не возвращает в следующий колбек придет\n//     // undefient\n//     x => {\n//       console.log(x);\n//     }\n//   )\n//   .then(\n//     // этот then() вернет undefient\n//     y => {\n//       console.log(y);\n//     }\n//   )\n//   .catch(error => {\n//     console.log(error);\n//   })\n//   .finally(() => {\n//     console.log('Я выполнюсь всегда');\n//   });\n"],"names":["Object","defineProperty","$da4b248c00322402$exports","value","default","obj","key","enumerable","configurable","writable","$85a5f86b715fe7db$var$Car","static","carObj","console","log","changePrice","newPrice","this","price","updateModel","newModel","model","_model","_price","constructor","brand","_brand","$parcel$interopDefault","$85a5f86b715fe7db$var$promise","Promise","resolve","reject","canFullfill","Math","random","setTimeout"],"version":3,"file":"index.95eca6be.js.map"}